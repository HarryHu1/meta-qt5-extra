From 86cad3e0edba28de83725bf7f55ceb68ff57d765 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andreas=20M=C3=BCller?= <schnitzeltony@gmail.com>
Date: Thu, 15 Mar 2018 14:47:57 +0100
Subject: [PATCH] fix build with GLES2 only
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Upstream-Status: Pending

Signed-off-by: Andreas MÃ¼ller <schnitzeltony@gmail.com>
---
 libs/ui/canvas/kis_mirror_axis.cpp           |  5 ++-
 libs/ui/opengl/kis_opengl_canvas2.cpp        | 18 ++++++++++
 libs/ui/opengl/kis_opengl_image_textures.cpp | 54 ++++++++++++++++++++++++----
 libs/ui/opengl/kis_texture_tile.cpp          | 10 ++++++
 4 files changed, 79 insertions(+), 8 deletions(-)

diff --git a/libs/ui/canvas/kis_mirror_axis.cpp b/libs/ui/canvas/kis_mirror_axis.cpp
index 47d115c..a873040 100644
--- a/libs/ui/canvas/kis_mirror_axis.cpp
+++ b/libs/ui/canvas/kis_mirror_axis.cpp
@@ -157,6 +157,7 @@ void KisMirrorAxis::drawDecoration(QPainter& gc, const QRectF& updateArea, const
     gc.setRenderHints(QPainter::Antialiasing | QPainter::SmoothPixmapTransform);
 
     QOpenGLContext *ctx = QOpenGLContext::currentContext();
+#ifdef GL_MULTISAMPLE
     bool hasMultisample = ((gc.paintEngine()->type() == QPaintEngine::OpenGL2) &&
                            (ctx->hasExtension("GL_ARB_multisample")));
 
@@ -167,7 +168,7 @@ void KisMirrorAxis::drawDecoration(QPainter& gc, const QRectF& updateArea, const
         ctx->functions()->glEnable(GL_MULTISAMPLE);
         gc.endNativePainting();
     }
-
+#endif
     float halfHandleSize = d->handleSize / 2;
 
     d->recomputeVisibleAxes(gc.viewport());
@@ -225,11 +226,13 @@ void KisMirrorAxis::drawDecoration(QPainter& gc, const QRectF& updateArea, const
         }
     }
 
+#ifdef GL_MULTISAMPLE
     if (hasMultisample) {
         gc.beginNativePainting();
         ctx->functions()->glDisable(GL_MULTISAMPLE);
         gc.endNativePainting();
     }
+#endif
 
 }
 
diff --git a/libs/ui/opengl/kis_opengl_canvas2.cpp b/libs/ui/opengl/kis_opengl_canvas2.cpp
index ab471b0..c7f09b3 100644
--- a/libs/ui/opengl/kis_opengl_canvas2.cpp
+++ b/libs/ui/opengl/kis_opengl_canvas2.cpp
@@ -45,8 +45,10 @@
 #include <QMessageBox>
 
 #ifndef Q_OS_OSX
+#ifndef QT_OPENGL_ES_2
 #include <QOpenGLFunctions_2_1>
 #endif
+#endif
 
 #define NEAR_VAL -1000.0
 #define FAR_VAL 1000.0
@@ -103,7 +105,9 @@ public:
     QVector2D texCoords[6];
 
 #ifndef Q_OS_OSX
+#ifndef QT_OPENGL_ES_2
     QOpenGLFunctions_2_1 *glFn201;
+#endif
 #endif
 
     int xToColWithWrapCompensation(int x, const QRect &imageRect) {
@@ -231,6 +235,7 @@ void KisOpenGLCanvas2::initializeGL()
     KisOpenGL::initializeContext(context());
     initializeOpenGLFunctions();
 #ifndef Q_OS_OSX
+#ifndef QT_OPENGL_ES_2
     if (!KisOpenGL::hasOpenGLES()) {
         d->glFn201 = context()->versionFunctions<QOpenGLFunctions_2_1>();
         if (!d->glFn201) {
@@ -239,6 +244,7 @@ void KisOpenGLCanvas2::initializeGL()
     } else {
         d->glFn201 = nullptr;
     }
+#endif
 #endif
 
     KisConfig cfg;
@@ -396,18 +402,28 @@ void KisOpenGLCanvas2::paintToolOutline(const QPainterPath &path)
     d->cursorShader->setUniformValue(d->cursorShader->location(Uniform::ModelViewProjection), modelMatrix);
 
     if (!KisOpenGL::hasOpenGLES()) {
+#ifdef GL_LINE_SMOOTH_HINT
         glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
+#endif
 
+#ifdef GL_COLOR_LOGIC_OP
         glEnable(GL_COLOR_LOGIC_OP);
+#endif
 #ifndef Q_OS_OSX
+#ifndef QT_OPENGL_ES_2
         if (d->glFn201) {
             d->glFn201->glLogicOp(GL_XOR);
         }
+#endif
 #else
+#ifdef GL_XOR
         glLogicOp(GL_XOR);
+#endif
 #endif
     } else {
+#ifdef GL_BLEND
         glEnable(GL_BLEND);
+#endif
         glBlendFuncSeparate(GL_ONE_MINUS_DST_COLOR, GL_ZERO, GL_ONE, GL_ONE);
     }
 
@@ -446,7 +462,9 @@ void KisOpenGLCanvas2::paintToolOutline(const QPainterPath &path)
     }
 
     if (!KisOpenGL::hasOpenGLES()) {
+#ifdef GL_COLOR_LOGIC_OP
         glDisable(GL_COLOR_LOGIC_OP);
+#endif
     } else {
         glDisable(GL_BLEND);
     }
diff --git a/libs/ui/opengl/kis_opengl_image_textures.cpp b/libs/ui/opengl/kis_opengl_image_textures.cpp
index 1210c7b..8aa84b7 100644
--- a/libs/ui/opengl/kis_opengl_image_textures.cpp
+++ b/libs/ui/opengl/kis_opengl_image_textures.cpp
@@ -408,7 +408,11 @@ void KisOpenGLImageTextures::generateCheckerTexture(const QImage &checkImage)
         if (checkImage.width() != BACKGROUND_TEXTURE_SIZE || checkImage.height() != BACKGROUND_TEXTURE_SIZE) {
             img = checkImage.scaled(BACKGROUND_TEXTURE_SIZE, BACKGROUND_TEXTURE_SIZE);
         }
+#ifdef GL_RGBA8
         GLint format = GL_BGRA, internalFormat = GL_RGBA8;
+#else
+        GLint format = GL_BGRA, internalFormat = GL_BGRA;
+#endif
         if (KisOpenGL::hasOpenGLES()) {
             if (ctx->hasExtension(QByteArrayLiteral("GL_EXT_texture_format_BGRA8888"))) {
                 format = GL_BGRA_EXT;
@@ -541,18 +545,25 @@ void KisOpenGLImageTextures::updateTextureFormat()
     QOpenGLContext *ctx = QOpenGLContext::currentContext();
     if (!(m_image && ctx)) return;
 
+#ifdef GL_RGBA8
     if (!KisOpenGL::hasOpenGLES()) {
         m_texturesInfo.internalFormat = GL_RGBA8;
         m_texturesInfo.type = GL_UNSIGNED_BYTE;
         m_texturesInfo.format = GL_BGRA;
-    } else {
+    } else
+#endif
+    {
         m_texturesInfo.internalFormat = GL_BGRA8_EXT;
         m_texturesInfo.type = GL_UNSIGNED_BYTE;
         m_texturesInfo.format = GL_BGRA_EXT;
         if(!ctx->hasExtension(QByteArrayLiteral("GL_EXT_texture_format_BGRA8888"))) {
             // The red and blue channels are swapped, but it will be re-swapped
             // by texture swizzle mask set in KisTextureTile::setTextureParameters
+#ifdef GL_RGBA8
             m_texturesInfo.internalFormat = GL_RGBA8;
+#else
+            m_texturesInfo.internalFormat = GL_RGBA;
+#endif
             m_texturesInfo.type = GL_UNSIGNED_BYTE;
             m_texturesInfo.format = GL_RGBA;
         }
@@ -569,32 +580,48 @@ void KisOpenGLImageTextures::updateTextureFormat()
     if (colorModelId == RGBAColorModelID) {
         if (colorDepthId == Float16BitsColorDepthID) {
 
+#ifdef GL_RGBA16F
             if (KisOpenGL::hasOpenGLES()) {
                 m_texturesInfo.internalFormat = GL_RGBA16F;
                 dbgUI << "Using half (GLES)";
-            } else if (ctx->hasExtension("GL_ARB_texture_float")) {
+            } else
+#endif
+#ifdef GL_RGBA16F_ARB
+            if (ctx->hasExtension("GL_ARB_texture_float")) {
                 m_texturesInfo.internalFormat = GL_RGBA16F_ARB;
                 dbgUI << "Using ARB half";
             }
-            else if (ctx->hasExtension("GL_ATI_texture_float")) {
+            else
+#endif
+#ifdef GL_RGBA_FLOAT16_ATI
+            if (ctx->hasExtension("GL_ATI_texture_float")) {
                 m_texturesInfo.internalFormat = GL_RGBA_FLOAT16_ATI;
                 dbgUI << "Using ATI half";
             }
+#endif
+            // make ifdefs 'else' happy
+            if(false) {}
 
             bool haveBuiltInOpenExr = false;
 #ifdef HAVE_OPENEXR
             haveBuiltInOpenExr = true;
 #endif
 
+#ifdef GL_HALF_FLOAT
             if (haveBuiltInOpenExr && KisOpenGL::hasOpenGLES()) {
                 m_texturesInfo.type = GL_HALF_FLOAT;
                 destinationColorDepthId = Float16BitsColorDepthID;
                 dbgUI << "Pixel type half (GLES)";
-            } else if (haveBuiltInOpenExr && ctx->hasExtension("GL_ARB_half_float_pixel")) {
+            } else
+#endif
+#ifdef GL_HALF_FLOAT_ARB
+            if (haveBuiltInOpenExr && ctx->hasExtension("GL_ARB_half_float_pixel")) {
                 m_texturesInfo.type = GL_HALF_FLOAT_ARB;
                 destinationColorDepthId = Float16BitsColorDepthID;
                 dbgUI << "Pixel type half";
-            } else {
+            } else 
+#endif
+            {
                 m_texturesInfo.type = GL_FLOAT;
                 destinationColorDepthId = Float32BitsColorDepthID;
                 dbgUI << "Pixel type float";
@@ -602,22 +629,32 @@ void KisOpenGLImageTextures::updateTextureFormat()
             m_texturesInfo.format = GL_RGBA;
         }
         else if (colorDepthId == Float32BitsColorDepthID) {
+            m_texturesInfo.internalFormat = GL_RGBA;
+#ifdef GL_RGBA32F
             if (KisOpenGL::hasOpenGLES()) {
                 m_texturesInfo.internalFormat = GL_RGBA32F;
                 dbgUI << "Using float (GLES)";
-            } else if (ctx->hasExtension("GL_ARB_texture_float")) {
+            } else
+#endif
+#ifdef GL_RGBA32F_ARB
+            if (ctx->hasExtension("GL_ARB_texture_float")) {
                 m_texturesInfo.internalFormat = GL_RGBA32F_ARB;
                 dbgUI << "Using ARB float";
-            } else if (ctx->hasExtension("GL_ATI_texture_float")) {
+            } else
+#endif
+#ifdef GL_RGBA_FLOAT32_ATI
+            if (ctx->hasExtension("GL_ATI_texture_float")) {
                 m_texturesInfo.internalFormat = GL_RGBA_FLOAT32_ATI;
                 dbgUI << "Using ATI float";
             }
+#endif
 
             m_texturesInfo.type = GL_FLOAT;
             m_texturesInfo.format = GL_RGBA;
             destinationColorDepthId = Float32BitsColorDepthID;
         }
         else if (colorDepthId == Integer16BitsColorDepthID) {
+#ifdef GL_RGBA16
             if (!KisOpenGL::hasOpenGLES()) {
                 m_texturesInfo.internalFormat = GL_RGBA16;
                 m_texturesInfo.type = GL_UNSIGNED_SHORT;
@@ -625,9 +662,11 @@ void KisOpenGLImageTextures::updateTextureFormat()
                 destinationColorDepthId = Integer16BitsColorDepthID;
                 dbgUI << "Using 16 bits rgba";
             }
+#endif
             // TODO: for ANGLE, see if we can convert to 16f to support 10-bit display
         }
     }
+#ifdef GL_RGBA16
     else {
         // We will convert the colorspace to 16 bits rgba, instead of 8 bits
         if (colorDepthId == Integer16BitsColorDepthID && !KisOpenGL::hasOpenGLES()) {
@@ -639,6 +678,7 @@ void KisOpenGLImageTextures::updateTextureFormat()
         }
         // TODO: for ANGLE, see if we can convert to 16f to support 10-bit display
     }
+#endif
 
     if (!m_internalColorManagementActive &&
             colorModelId != destinationColorModelId) {
diff --git a/libs/ui/opengl/kis_texture_tile.cpp b/libs/ui/opengl/kis_texture_tile.cpp
index d8fb03d..90e9996 100644
--- a/libs/ui/opengl/kis_texture_tile.cpp
+++ b/libs/ui/opengl/kis_texture_tile.cpp
@@ -34,17 +34,27 @@ void KisTextureTile::setTextureParameters()
 
     f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
     f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+#ifdef GL_TEXTURE_MIN_LOD
     f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_LOD, 0);
+#endif
+#ifdef GL_TEXTURE_MAX_LOD
     f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LOD, m_numMipmapLevels);
+#endif
+#ifdef GL_TEXTURE_BASE_LEVEL
     f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
+#endif
+#ifdef GL_TEXTURE_MAX_LEVEL
     f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, m_numMipmapLevels);
+#endif
 
+#ifdef GL_RGBA8
     if (m_texturesInfo->internalFormat == GL_RGBA8 && m_texturesInfo->format == GL_RGBA) {
         // If image format is RGBA8, swap the red and blue channels for the proper colour
         // This is for OpenGL ES support and only used if lacking GL_EXT_texture_format_BGRA8888
         f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_R, GL_BLUE);
         f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_B, GL_RED);
     }
+#endif
 
     f->glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
 }
-- 
2.14.3

